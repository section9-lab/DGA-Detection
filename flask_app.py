# app.py - Flask application for DGA domain detection
import os
import pickle
import numpy as np
from flask import Flask, request, jsonify, render_template, url_for
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.layers import Layer
from tensorflow.keras.preprocessing.sequence import pad_sequences
import json

# Define the custom AttentionLayer class
class AttentionLayer(Layer):
    def __init__(self, **kwargs):
        super(AttentionLayer, self).__init__(**kwargs)
        
    def build(self, input_shape):
        self.W = self.add_weight(name="att_weight", shape=(input_shape[-1], 1),
                               initializer="normal")
        self.b = self.add_weight(name="att_bias", shape=(input_shape[1], 1),
                               initializer="zeros")
        super(AttentionLayer, self).build(input_shape)
        
    def call(self, x):
        # Calculate attention scores
        e = tf.nn.tanh(tf.matmul(x, self.W) + self.b)
        
        # Get attention weights
        a = tf.nn.softmax(e, axis=1)
        
        # Apply attention weights to the input
        output = x * a
        
        # Sum over the sequence dimension
        return tf.reduce_sum(output, axis=1)
    
    def compute_output_shape(self, input_shape):
        return input_shape[0], input_shape[-1]
    
    # Add get_config method for serialization
    def get_config(self):
        config = super(AttentionLayer, self).get_config()
        return config

# Initialize Flask application
app = Flask(__name__)

# Global variables for model, tokenizer, and configuration
model = None
tokenizer = None
max_length = None

# Load model and preprocessing components
def load_detection_model():
    global model, tokenizer, max_length
    
    try:
        print("Loading model and preprocessing components...")
        
        # Load the model with custom objects
        model_path = "ML_v2/dga_lstm_attention_model.h5"
        if not os.path.exists(model_path):
            raise FileNotFoundError(f"Model file not found at {model_path}")
        
        # Register the custom layer
        custom_objects = {"AttentionLayer": AttentionLayer}
        model = load_model(model_path, custom_objects=custom_objects)
        
        # Load tokenizer
        tokenizer_path = "ML_v2/dga_tokenizer.pickle"
        if not os.path.exists(tokenizer_path):
            raise FileNotFoundError(f"Tokenizer file not found at {tokenizer_path}")
            
        with open(tokenizer_path, 'rb') as handle:
            tokenizer = pickle.load(handle)
        
        # Load config
        config_path = "ML_v2/dga_config.pickle"
        if not os.path.exists(config_path):
            raise FileNotFoundError(f"Config file not found at {config_path}")
            
        with open(config_path, 'rb') as handle:
            config = pickle.load(handle)
            max_length = config['max_length']
        
        print("Model and components loaded successfully!")
        return True
        
    except Exception as e:
        print(f"Error loading model: {str(e)}")
        return False

# Predict function
def predict_domain(domain):
    # Preprocess domain
    domain = domain.lower()
    sequence = tokenizer.texts_to_sequences([domain])
    padded = pad_sequences(sequence, maxlen=max_length, padding='post')
    
    # Make prediction
    prediction = float(model.predict(padded, verbose=0)[0][0])
    is_dga = prediction > 0.5
    confidence = prediction if is_dga else 1 - prediction
    
    return {
        "domain": domain,
        "prediction": "DGA" if is_dga else "Legitimate",
        "is_dga": is_dga,
        "confidence": float(confidence)
    }

# Create templates directory and files if they don't exist
def create_templates():
    if not os.path.exists("templates"):
        os.makedirs("templates")
    
    # Create index.html template
    if not os.path.exists("templates/index.html"):
        with open("templates/index.html", "w") as f:
            f.write("""
<!DOCTYPE html>
<html>
<head>
    <title>DGA Domain Detection</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; }
        .result-card { margin-top: 20px; }
        .confidence-bar { height: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="mb-4">DGA Domain Detection</h1>
        <div class="card">
            <div class="card-body">
                <h5 class="card-title">Check if a domain is generated by a DGA</h5>
                <form id="domain-form" method="post" action="/check">
                    <div class="mb-3">
                        <label for="domain" class="form-label">Domain Name:</label>
                        <input type="text" class="form-control" id="domain" name="domain" required
                               placeholder="Enter a domain name (e.g., google.com, example.net)">
                    </div>
                    <button type="submit" class="btn btn-primary">Check Domain</button>
                </form>
            </div>
        </div>

        {% if result %}
        <div class="card result-card">
            <div class="card-body">
                <h5 class="card-title">Detection Result</h5>
                <p><strong>Domain:</strong> {{ result.domain }}</p>
                <p><strong>Classification:</strong> 
                    {% if result.is_dga %}
                    <span class="badge bg-danger">DGA</span>
                    {% else %}
                    <span class="badge bg-success">Legitimate</span>
                    {% endif %}
                </p>
                <p><strong>Confidence:</strong> {{ "%.2f"|format(result.confidence*100) }}%</p>
                <div class="progress">
                    <div class="progress-bar {% if result.is_dga %}bg-danger{% else %}bg-success{% endif %}" 
                         role="progressbar" 
                         style="width: {{ result.confidence*100 }}%" 
                         aria-valuenow="{{ result.confidence*100 }}" 
                         aria-valuemin="0" 
                         aria-valuemax="100">
                        {{ "%.2f"|format(result.confidence*100) }}%
                    </div>
                </div>
            </div>
        </div>
        {% endif %}

        <div class="card mt-4">
            <div class="card-body">
                <h5 class="card-title">API Usage</h5>
                <p>You can also use the API endpoint directly:</p>
                <pre><code>POST /api/detect
Content-Type: application/json

{
    "domain": "example.com"
}</code></pre>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
            """)

# Create necessary directories and templates
create_templates()

# Load model before handling requests
if not load_detection_model():
    raise RuntimeError("Failed to load model and components")

# Routes definition
@app.route('/')
def home():
    """Render the home page with a form to test domain detection"""
    return render_template('index.html')

@app.route('/check', methods=['POST'])
def check_form():
    """Handle form submission and render results"""
    domain = request.form.get('domain', '')
    if not domain:
        return render_template('index.html', error="Domain cannot be empty")
    
    result = predict_domain(domain)
    return render_template('index.html', result=result)

@app.route('/api/detect', methods=['POST'])
def detect_domain():
    """API endpoint for domain detection"""
    data = request.get_json()
    
    if not data or 'domain' not in data:
        return jsonify({"error": "Domain not provided"}), 400
    
    domain = data['domain']
    if not domain or len(domain.strip()) == 0:
        return jsonify({"error": "Domain cannot be empty"}), 400
    
    result = predict_domain(domain)
    return jsonify(result)

@app.route('/health', methods=['GET'])
def health_check():
    """Health check endpoint"""
    return jsonify({"status": "ok"})

@app.route('/api/batch-detect', methods=['POST'])
def batch_detect():
    """Process multiple domains at once"""
    domains = request.get_json()
    
    if not domains or not isinstance(domains, list):
        return jsonify({"error": "Domain list not provided or invalid format"}), 400
    
    if len(domains) > 100:
        return jsonify({"error": "Maximum 100 domains allowed per request"}), 400
    
    results = []
    for domain in domains:
        if domain and isinstance(domain, str) and len(domain.strip()) > 0:
            results.append(predict_domain(domain))
    
    return jsonify({
        "total": len(results),
        "results": results
    })

# Run the application
if __name__ == "__main__":
    app.run(host='0.0.0.0', port=8000, debug=True)